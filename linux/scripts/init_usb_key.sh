#!/bin/bash
# SPDX-License-Identifier: LGPL-2.1-or-later
# Copyright © 2007-2018 ANSSI. All Rights Reserved.

# init_usb_key.sh - initialize a USB token at a given level
# Author: Vincent Strubel <clipos@ssi.gouv.fr>
# Based on code by EADS DCS and EADS IW
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License version
# 2 as published by the Free Software Foundation.
#

#Error messages
ERROR_NO_DEVICE="Aucun support initialisable n'est présent.
N.B. : les supports montés ne peuvent pas être initialisés."
ERROR_SYM_KEY="Erreur dans la génération de la clé symétrique"
ERROR_SYM_CRYPT="Erreur dans le chiffrement de la clé symétrique"
ERROR_METADATA_STORE="Erreur d'écriture des métadonnées"
ERROR_SYM_STORE="Erreur dans le stockage de la clé symétrique chiffrée dans le secteur d'information"
ERROR_HASH_CALC="Erreur dans le hachage des méta données"
ERROR_HASH_SIGN="Erreur dans la signature des méta données (mot de passe invalide ?)"
ERROR_HASH_INJECT="Erreur dans l'injection du hachage des méta données"
ERROR_INFO_SEC_PADD="Erreur dans le bourrage du secteur information"
ERROR_FILL_RAND="Erreur lors du remplissage aléatoire du périphérique"
ERROR_PART="Erreur lors du partitionnement du périphérique"
ERROR_INJECT_SECTOR="Erreur lors de l'injection du secteur de méta données"
ERROR_FS_CREATE="Erreur lors de la création du système de fichiers"
ERROR_VDEV_DEL="Erreur lors de la suppression du périphérique virtuel"
ERROR_BAD_ARG="Paramètre incorrect"
ERROR_REGET_SYM_KEY="Echec de la conversion hexa de la clé symétrique"
ERROR_IN_USE="Clef en cours d'utilisation"
ERROR_CANCEL="Opération annulée"
ERROR_SECTOR_CORRUPT="Secteurs d'information corrompus"
ERROR_GETTING_SYM_HEXA_KEY="Impossible de récupérer la clé symétrique"

#Info messages
INFO_LEVEL_EXTRACT="Niveau lu"
INFO_CIPHER="Chiffrement"
INFO_SIGNATURE="Signature"
INFO_GEN_SECTOR="Generation du secteur d'information"
INFO_SECTOR_OK="Secteur d'information pret"
INFO_PART="Partitionnement du peripherique (peut etre long)"
INFO_INJECT="Injection des secteurs d'information"
INFO_FS_CREATE="Creation du systeme de fichiers"
INFO_DEV_INIT="Initialisation du peripherique"
INFO_DEV_OK="Le peripherique est pret a l'usage."

SCRIPT_NAME="INIT_USB"
XDIALOG_ERROR_TITLE="Initialisation de clé USB"
DEVTYPE="usb"
source /lib/clip/usb_storage.sub || exit 1

####################################
############ Util code #############
####################################

function clean_up()
{
	[[ -n "${FILE_INFO_SECTOR}" && -f "${FILE_INFO_SECTOR}" ]] \
		&& rm -f "${FILE_INFO_SECTOR}"
}

function get_rnd_str
{
	echo -ne $(dd if=${RANDOM_FILE} bs=1 count=32 2>/dev/null | od -tx1 -An | tr -d ' \n')
}

########################################
############ Info Sector Code ##########
########################################

function append_metadata()
{
	dd if=${ZERO_FILE} of="${FILE_INFO_SECTOR}" bs=1 \
			count="${SECTOR_METADATA_SIZE}" \
			seek="${SECTOR_ID_SIZE}" 2>/dev/null \
		|| error "${ERROR_METADATA_STORE}"
}

#encrypt symetric user key with user asymetric encryption key
# 256 bytes are generated by RSA with padding
function encrypt_user_sym_key()
{
	info "${INFO_CIPHER} : key ${CRYPT_PUB_KEY}"
	info "FILE_INFO_SECTOR: ${FILE_INFO_SECTOR}"
	local -i skip=$((${SECTOR_ID_SIZE} + ${SECTOR_METADATA_SIZE}))

	if [[ -z "${CLEARTEXT_MOUNT}" ]]; then
		dd if=${RANDOM_FILE} bs=1 count=${USER_SYM_KEY_SIZE} 2>/dev/null \
		| openssl rsautl -oaep -encrypt -pubin \
				-inkey ${CRYPT_PUB_KEY} >/dev/null  \
			|| error "${ERROR_SYM_CRYPT}" 
	
		dd if=${RANDOM_FILE} bs=1 count=${USER_SYM_KEY_SIZE} 2>/dev/null \
		| openssl rsautl -oaep -encrypt -pubin -inkey ${CRYPT_PUB_KEY} \
		| dd of=${FILE_INFO_SECTOR} bs=1 \
				count=${SECTOR_SYM_KEY_CRYPT_SIZE} \
				seek=${skip} 2>/dev/null \
			|| error "${ERROR_SYM_STORE}"
	else
		dd if="${RANDOM_FILE}" of="${FILE_INFO_SECTOR}" bs=1 \
				count="${SECTOR_SYM_KEY_CRYPT_SIZE}" \
				seek="${skip}" 2>/dev/null \
			|| error "${ERROR_SYM_STORE}"
	fi
}

#sign "id+encrypted user symetric key" with user asymetric signing key
# 256 bytes are generated by RSA with padding
function sign_id_sym_key_crypt()
{ 
	local pass="$(gen_passphrase "sig" "${PASSPHRASE}")"
	local devinfo hash1

	devinfo="$(get_device_info "${BASE_DEVICE}" )"
	[[ $? -eq 0 ]] || error "${ERROR_GET_DEVINFO}"
	debug "Initializing device : ${devinfo}"

	info "${INFO_SIGNATURE}"

	local -i skip=$((${SECTOR_ID_SIZE}+${SECTOR_METADATA_SIZE}+${SECTOR_SYM_KEY_CRYPT_SIZE}))

	hash1="$(openssl dgst -sha256 < "${FILE_INFO_SECTOR}" | cut -d' ' -f 2)"
	[[ $? -eq 0 && -n "${hash1}" ]] || error "${ERROR_HASH_CALC}"

	hash1="${devinfo}:${hash1}"

	echo "${hash1}" | openssl rsautl -sign -inkey ${SIGN_PRV_KEY} \
			-passin pass:"${pass}" >/dev/null \
		|| error "${ERROR_HASH_SIGN}"

	echo "${hash1}" \
		| openssl rsautl -sign -inkey ${SIGN_PRV_KEY} -passin pass:"${pass}" 2>/dev/null \
		| dd of=${FILE_INFO_SECTOR} bs=1 \
				count=${SECTOR_SIGNATURE_SIZE} \
				seek=${skip} 2>/dev/null \
			|| error "${ERROR_HASH_INJECT}"
}

function gen_info_sector()
{
	info "${INFO_GEN_SECTOR}"

	#first put level id
	echo -ne "${CURRENT_LEVEL}" > "${FILE_INFO_SECTOR}"

	append_metadata

	#gen, encrypt and write into info sector file the symetric key
	encrypt_user_sym_key

	#sign that data and put signature into info sector file
	sign_id_sym_key_crypt

	#padding until end of sector
	dd if=${RANDOM_FILE} of=${FILE_INFO_SECTOR} bs=1 \
			count=${SECTOR_PADD_SIZE} \
			seek=${SECTOR_DATA_SIZE} 2>/dev/null \
		|| error "${ERROR_INFO_SEC_PADD}"

	#ok info sector is ready
	info "${INFO_SECTOR_OK}"
}

########################################
############# Init Key Code ############
########################################

function random_fill_device()
{
	dd if=${RANDOM_FILE} of=${BASE_DEVICE} >/dev/null 2>&1 \
		|| error "${ERROR_FILL_RAND}: ${BASE_DEVICE}"
}

function partition_device()
{
	local cyls=""
	local type="da"
	[[ -n "${CLEARTEXT_MOUNT}" ]] && type="b"
	cyls="$(sfdisk -g ${BASE_DEVICE} | awk '{print $2}')"

	[[ $? -eq 0 ]] || error "${ERROR_PART}"

	cyls=$((cyls - 1))
	sfdisk ${BASE_DEVICE} >/dev/null 2>&1 <<EOF
,${cyls},${type}
,1,da
;
;
EOF
	[[ $? -eq 0 ]] || error "${ERROR_PART}"
}

function write_info_sectors()
{
	info "${INFO_INJECT}"

	#first physical sector
	dd if=${FILE_INFO_SECTOR} of=${DEVICE_META} \
			bs=${SECTOR_SIZE} count=1 >/dev/null 2>&1 \
		|| error "${ERROR_INJECT_SECTOR}"
}

function reread_sym_key()
{
	[[ -n "${CLEARTEXT_MOUNT}" ]] && return 0

	local -i skip=$((${SECTOR_ID_SIZE} + ${SECTOR_METADATA_SIZE}))
	local pass="$(gen_passphrase "enc" "${PASSPHRASE}")"

	SYM_KEY_HEXA="$(dd if=${DEVICE_META} bs=1 \
		count=${SECTOR_SYM_KEY_CRYPT_SIZE} skip=${skip} 2>/dev/null | \
		openssl rsautl -oaep -decrypt \
		-inkey ${CRYPT_PRV_KEY} -passin pass:"${pass}" 2>/dev/null | \
		od -tx1 -An | tr -d ' \n')"
	[[ -n "${SYM_KEY_HEXA}" ]] || error "${ERROR_GETTING_SYM_HEXA_KEY}"
}

function build_filesystem()
{
	info "${INFO_FS_CREATE}"
	mkfs.vfat ${VIRTUAL_DEVICE_FULL} >/dev/null 2>&1 \
		|| error "${ERROR_FS_CREATE}"
}

function unmap_crypto_device()
{
	[[ -n "${CLEARTEXT_MOUNT}" ]] && return 0

	dmsetup remove ${VIRTUAL_DEVICE} \
		|| error "${ERROR_VDEV_DEL}"
}

function init_key()
{
	info "${INFO_DEV_INIT}"

	#random_fill_device
	partition_device
	write_info_sectors
	reread_sym_key
	map_device
	build_filesystem

	info "${INFO_DEV_OK}"
	local disp_level="$(get_jail_name "${CURRENT_STR_LEVEL}")"
	if [[ "${CURRENT_STR_LEVEL}" == "${STR_CLIP}" ]] || [[ "${CURRENT_STR_LEVEL}" == "${STR_ANY}" ]] ; then
		local msg="Le support est initialisé au niveau ${disp_level}.\nVous pouvez à présent le déconnecter."
		local title="Support de niveau ${disp_level} initialisé"
		unmap_crypto_device
		${USER_ENTER} -u "${CURRENT_UID}" -- ${DIALOG} "${AUTHORITY}" --wrap --title "${title}" --msgbox "${msg}" 0 0
	else 
		local msg="Le support est initialisé au niveau ${disp_level}.\nSouhaitez-vous le monter directement ?"
		local title="Montage du support USB de niveau ${disp_level}"
		if ${USER_ENTER} -u "${CURRENT_UID}" -- ${DIALOG} "${AUTHORITY}" \
					--wrap --title "${title}" --yesno "${msg}" 0 0
		then
			DEVPATH="/block/${BASE_DEVICE##*/}"
			mount_device
			return 0
		else
			unmap_crypto_device
			return 0
		fi
	fi
}

function extract_current_level()
{
	#get security level
	READ_LEVEL=$(dd if=${DEVICE_META} bs=1 count=${SECTOR_ID_SIZE} 2>/dev/null)
	[[ $? -eq 0 ]] || return 1

	for key in "${!SIGNED_IDS[@]}"; do
		if [[ "${READ_LEVEL}" == "$(echo -ne "${SIGNED_IDS[$key]}")" ]]; then
			READ_STR_LEVEL="${key}"
			READ_CLEARTEXT="yes"
			break
		fi
	done
	if [[ -z "${READ_STR_LEVEL}" ]]; then
		for key in "${!ENCRYPTED_IDS[@]}"; do
			if [[ "${READ_LEVEL}" == "$(echo -ne "${ENCRYPTED_IDS[$key]}")" ]]; then
				READ_STR_LEVEL="${key}"
				break
			fi
		done
	fi

	info "${INFO_LEVEL_EXTRACT}: ${READ_STR_LEVEL}"
}

function check_key () {
	VIRTUAL_DEVICE="${BASE_VIRTUAL_NAME}_${CURRENT_USER}_${JAIL}"
	#full virtual device name
	VIRTUAL_DEVICE_FULL="${DEV_MAPPER_PATH}/${VIRTUAL_DEVICE}"
	DM_COPY="${DM_COPY_PATH}/${VIRTUAL_DEVICE}"

	if [[ -e "${VIRTUAL_DEVICE_FULL}" || -e "${DM_COPY}" ]]; then

		local msg="Etes-vous sûr de vouloir ré-initialiser le support ?"
		local title="Initialisation du support USB au niveau $(get_jail_name ${CURRENT_STR_LEVEL})"

		if ! ${USER_ENTER} -u "${CURRENT_UID}" -- ${DIALOG} "${AUTHORITY}" --title "${title}" \
					--yesno "${msg}" 0 0
		then
			info "${ERROR_CANCEL}" "notify"

			clean_up

			exit 0
		fi

		if [[ -e "${DM_COPY}" ]]; then
			# No error if those fail - the device is not necessarily mounted
			# If it is, the error will be caught when dmsetup is called.
			nsmount -u -m "${MTAB}" -x ${XID} ${MOUNT_POINT}

			rm -f "${DM_COPY}"
		fi

		if [[ -z "${CLEARTEXT_MOUNT}" ]]; then
			dmsetup remove ${VIRTUAL_DEVICE} || error "${ERROR_IN_USE}"
		fi
	fi

	#extract level
	# if key not correctly initialized
	#or not initialized at all
	#impossible to read the level
	#proceed with the initialization
	extract_current_level || return 0 

	check_level "${READ_STR_LEVEL}" "nocheck"
}

function confirm_init() {
	local title="Confirmation de l'initialisation"
	local msg="Confirmez-vous l'initialisation du support USB au niveau"

	msg="${msg} $(get_jail_name "${CURRENT_STR_LEVEL}")"
	[[ -n "${CLEARTEXT_MOUNT}" ]] && msg="${msg} (non chiffré)"
	msg="${msg} ?\nAttention, l'initialisation d'un support supprime les données qu'il contient."
	
	${USER_ENTER} -u "${CURRENT_UID}" -- ${DIALOG} "${AUTHORITY}" --wrap \
			--title "${title}" --yesno "${msg}" 0 0 \
		|| exit 0
}

function get_jail_popup_init()
{
	local title="Initialisation d'un support ${DEVTYPE_NAME}"
	local msg="Pour quel compartiment souhaitez vous initialiser le support ${DEVTYPE_NAME} ?"
	
	get_jail_popup "${title}" "${msg}"
}

####################################
############ MAIN CODE #############
####################################

exec 150>>"${USB_LOCKFILE}"
flock -x 150 || error "${ERROR_LOCK}"

get_connected_user


get_available_device || error "${ERROR_NO_DEVICE}"

get_jail_popup_init || exit 0

[[ "${CURRENT_USER_TYPE}" == "privuser" ]] && CURRENT_USER_TYPE="admin"

#level id
if [[ "${1}" == "clear" ]]; then
	CLEARTEXT_MOUNT="yes"
	CURRENT_LEVEL="$(echo -ne "${SIGNED_IDS[${CURRENT_STR_LEVEL}]}")"
else 
	CURRENT_LEVEL="$(echo -ne "${ENCRYPTED_IDS[${CURRENT_STR_LEVEL}]}")"
fi
[[ -n "${CURRENT_LEVEL}" ]] || error "${ERROR_BAD_ARG}"


check_level_authorized

get_user_paths

check_keys

check_not_mounted

confirm_init

#usb device
## Init some usefull info ##

#info sector temporary file (maybe reusable some day for fast key build)
FILE_INFO_SECTOR="${ROOT_USER}/$(get_rnd_str)"

## Do the job with the key right now ##

# 0 - check the level to see if we can re-initialize the key
check_key
	
get_passphrase "initialisation" || error "${ERROR_PASSPHRASE}"

# 1 - prepare the info sector
gen_info_sector

# 2 - initialize the key
init_key

# 2.5 - remove file
clean_up

rm -f "${LASTDEV_FILE}"

exit 0




